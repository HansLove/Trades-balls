<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TradeTab — Bouncing-Style</title>
  <style>
    :root{
      --bg:#0b1220; /* deep navy */
      --panel:#111a2b;
      --accent:#48d597;
      --accent-2:#ef4444;
      --ink:#e6f0ff;
      --muted:#7b8aa1;
      --peg:#1f2d47;
      --grid:#0f1a30;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% -10%, #18243d 0%, var(--bg) 60%);}    
    body{font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; color:var(--ink);}

    /* Layout */
    .wrap{position:fixed; inset:0; display:grid; grid-template-columns: 1fr;}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}

    /* HUD */
    .hud{position:fixed; top:16px; right:16px; display:flex; gap:12px; align-items:flex-start; z-index:10}
    .hud.hidden{display:none}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03)); border:1px solid rgba(255,255,255,0.08); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border-radius:16px; padding:12px 14px; box-shadow: 0 10px 30px rgba(0,0,0,.25);} 
    .card h3{margin:0 0 8px 0; font-size:13px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted)}
    .row{display:flex; gap:8px; align-items:center; margin:8px 0}
    label{font-size:12px; color:var(--muted)}
    input[type="range"]{width:140px}
    .pill{display:inline-flex; align-items:center; gap:8px; background:#0f1a30; border:1px solid #1c2a45; padding:6px 10px; border-radius:999px; font-size:12px}
    .btn{cursor:pointer; user-select:none; border:none; border-radius:12px; padding:8px 12px; font-weight:600; background:#16223a; color:#dbe7ff; border:1px solid #203055; transition:transform .06s ease, background .2s}
    .btn:hover{background:#1a2a4a}
    .btn:active{transform:translateY(1px)}
    .dot{width:10px; height:10px; border-radius:50%}
    .dot.green{background:var(--accent)}
    .dot.red{background:var(--accent-2)}

    /* Footer */
    .footer{position:fixed; left:16px; bottom:16px; display:flex; gap:10px; align-items:center; z-index:10}
    .tag{font-size:12px; color:var(--muted)}

    /* Tooltip */
    .toast{position:fixed; left:50%; transform:translateX(-50%); top:16px; background:#0e1730; border:1px solid #203055; color:#dbe7ff; padding:8px 12px; border-radius:10px; font-size:12px; opacity:0; pointer-events:none; transition: opacity .25s ease}
    .toast.show{opacity:1}

    /* Bottom bins */
    .bins{position:fixed; left:0; right:0; bottom:0; height:120px; pointer-events:none}
    .bin{position:absolute; bottom:0; width:2px; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,0));}

    /* Nice subtle grid */
    .fg-grid{position:fixed; inset:0; pointer-events:none; background-image: linear-gradient(var(--grid) 1px, transparent 1px), linear-gradient(90deg, var(--grid) 1px, transparent 1px); background-size: 60px 60px; mask: linear-gradient(to bottom, rgba(0,0,0,.18), rgba(0,0,0,.6));}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="stage"></canvas>
    <div class="fg-grid"></div>

    <div class="hud">
      <div class="card" id="controls">
        <h3>Live Controls</h3>
        <div class="row">
          <button class="btn" id="toggle">Pause</button>
          <button class="btn" id="clear">Clear</button>
          <button class="btn" id="fullscreen">Fullscreen</button>
          <span class="pill"><span class="dot green"></span>Buy</span>
          <span class="pill"><span class="dot red"></span>Sell</span>
        </div>
        <div class="row">
          <label>Gravity</label>
          <input id="gravity" type="range" min="0" max="3" step="0.05" value="1.1" />
          <span id="gravityVal" class="tag">1.10</span>
        </div>
        <div class="row">
          <label>Spawn/sec</label>
          <input id="rate" type="range" min="0" max="15" step="1" value="6" />
          <span id="rateVal" class="tag">6</span>
        </div>
        <div class="row">
          <label>Max Balls</label>
          <input id="maxBalls" type="range" min="50" max="800" step="10" value="350" />
          <span id="maxVal" class="tag">350</span>
        </div>
        <div class="row">
          <label>Auto-Stream</label>
          <input id="auto" type="checkbox" checked />
        </div>
      </div>

      <div class="card" id="help">
        <h3>How to feed trades</h3>
        <div class="tag">From the console or another script, call:</div>
        <pre style="margin:6px 0 0; padding:8px 10px; background:#0c1530; border:1px solid #203055; border-radius:10px; overflow:auto; max-width:420px"><code style="font-size:12px; color:#bcd9ff; display:block">window.pushTrade({ side: "buy", lots: 0.3, profitUSD: 42, symbol: "XAUUSD" })
window.pushTrade({ side: "sell", profitUSD: -350, symbol: "BTCUSD" })
window.setTradeAdapter((p) => ({ side: p.s > 0 ? "buy" : "sell", profitUSD: p.s, symbol: p.sym, lots: p.l || 0.2 }))
window.setRandomStreamOptions({ buyProbability: 0.6, symbolPool: ["XAUUSD","EURUSD","US30"], bigProfitChance: 0.2 })</code></pre>
      </div>
    </div>

    <div class="footer">
      <!-- <div class="tag">Trade Rain · Canvas physics demo · ⌘/Ctrl+K to spawn 20</div> -->
    </div>

    <div id="toast" class="toast">Copied API usage to clipboard</div>

    <div class="bins" id="bins"></div>
  </div>

<script>
(function(){
  // ===== Utilities =====
  const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const rand = (a,b) => Math.random()*(b-a)+a;

  // ===== Canvas & Scene =====
  const c = document.getElementById('stage');
  const ctx = c.getContext('2d');
  let W=0,H=0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));

  const world = {
    gravity: 1.1, // px/frame^2 (scaled by DPR)
    running: true,
    maxBalls: 350,
    balls: [],
    lastSpawn: 0,
    spawnInterval: 1000/6, // ms per ball in auto mode
    adapter: null,
    randomOptions: {
      buyProbability: 0.5,
      symbolPool: ["XAUUSD","EURUSD","BTCUSD"],
      lotsRange: [0.05, 1.5],
      profitRangeSmall: [5, 250],
      profitRangeBig: [250, 2000],
      bigProfitChance: 0.3,
    },
    // 3D arena
    arenaHalfWidthX: 600,
    arenaDepthZ: 1400,
    arenaFloorY: 0,
    perspective: 1200,
    cameraYaw: -0.18,
    cameraPitch: -0.22,
    cameraZ: -260
  };

  // ===== 3D Projection helpers =====
  const FLOOR_SCREEN_Y = () => H - 90; // where the floor baseline renders on screen
  const Z_SKEW = 0.0; // no longer needed with camera pitch
  function project3D(pos){
    const cy = Math.cos(world.cameraYaw), syaw = Math.sin(world.cameraYaw);
    const cp = Math.cos(world.cameraPitch), sp = Math.sin(world.cameraPitch);
    const rx = pos.x*cy - pos.z*syaw;
    const rzYaw = pos.z*cy + pos.x*syaw;
    const ry = pos.y*cp - rzYaw*sp;
    const rz = rzYaw*cp + pos.y*sp - world.cameraZ; // camera forward shift
    const persp = world.perspective;
    const scale = persp / (persp + rz);
    const sx = (W*0.5) + rx * scale;
    const sy = FLOOR_SCREEN_Y() - ry * scale;
    return { x: sx, y: sy, scale, zCam: rz };
  }

  function resize(){
    W = c.clientWidth = window.innerWidth;
    H = c.clientHeight = window.innerHeight;
    c.width = Math.floor(W*DPR);
    c.height = Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    // nothing else for 3D scene
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // (Plinko grid and spatial hash removed)

  // ===== Balls =====
  class Ball{
    constructor({x,y,z,r,color,label}){
      this.x = x; this.y = y; this.z = z; this.r = r; this.color = color; this.label = label||'';
      this.vx = rand(-0.5,0.5); this.vy = 0; this.vz = rand(-0.2,0.2);
      this.sleep = false; // when settled at the bottom
      // mass scales with size so bigger balls dominate collisions
      this.m = Math.max(1, r*r);
    }
  }

  function mapRadiusFromProfitUSD(usd){
    const s = Math.log10(Math.abs(usd) + 10); // log scale
    const sMin = Math.log10(10); // 1
    const sMax = Math.log10(2000 + 10); // ~3.303
    const t = clamp((s - sMin) / (sMax - sMin), 0, 1);
    return lerp(6, 26, t);
  }
  function mapRadiusFromLots(lots){
    const l = clamp(lots, 0.05, 3.0);
    const t = (l - 0.05) / (3.0 - 0.05);
    return lerp(6, 26, clamp(t, 0, 1));
  }

  function spawnBall(trade){
    const side = (trade?.side||'buy').toLowerCase();
    const lots = Number(trade?.lots ?? 0.2);
    const usd = Number(trade?.profitUSD);
    // Radius mapping: 6px to 26px based on |usd| or lots
    const r = Math.round(
      isFinite(usd) && !Number.isNaN(usd) ? mapRadiusFromProfitUSD(usd) : mapRadiusFromLots(lots)
    );
    const color = side==='sell' ? '#ef4444' : '#48d597';

    const x = rand(-world.arenaHalfWidthX*0.85, world.arenaHalfWidthX*0.85);
    const z = rand(40, world.arenaDepthZ*0.25);
    const y = rand(220, 360);
    const b = new Ball({x,y,z,r,color,label: trade?.symbol||''});
    world.balls.push(b);
    if(world.balls.length > world.maxBalls){
      world.balls.splice(0, world.balls.length - world.maxBalls);
    }
  }

  // Public API to feed trades
  window.pushTrade = function(trade){
    try{
      if(typeof world.adapter === 'function'){
        const adapted = world.adapter(trade);
        if(adapted && typeof adapted === 'object') trade = adapted;
      }
    }catch(e){ /* ignore adapter errors */ }
    spawnBall(trade);
  }

  window.setTradeAdapter = function(adapter){
    world.adapter = (typeof adapter === 'function') ? adapter : null;
  }

  window.setRandomStreamOptions = function(opts={}){
    const ro = world.randomOptions;
    if('buyProbability' in opts && typeof opts.buyProbability === 'number') ro.buyProbability = clamp(opts.buyProbability, 0, 1);
    if(Array.isArray(opts.symbolPool) && opts.symbolPool.length) ro.symbolPool = opts.symbolPool.slice(0, 24);
    if(Array.isArray(opts.lotsRange) && opts.lotsRange.length===2) ro.lotsRange = [Math.max(0.01, opts.lotsRange[0]), Math.max(0.02, opts.lotsRange[1])];
    if(Array.isArray(opts.profitRangeSmall) && opts.profitRangeSmall.length===2) ro.profitRangeSmall = opts.profitRangeSmall;
    if(Array.isArray(opts.profitRangeBig) && opts.profitRangeBig.length===2) ro.profitRangeBig = opts.profitRangeBig;
    if('bigProfitChance' in opts && typeof opts.bigProfitChance === 'number') ro.bigProfitChance = clamp(opts.bigProfitChance, 0, 1);
  }

  // ===== Physics =====
  const bounce = 0.58; // restitution on floor
  const air = 0.997;   // air drag
  const floorY = 0;    // world floor plane y

  // Spatial hash in XZ-plane for sphere-sphere collisions
  const cellXZ = 64;
  const gridXZ = new Map();
  function keyXZ(x,z){ return ((x/cellXZ)|0)+","+((z/cellXZ)|0); }

  function step(dt){
    const g = world.gravity * (dt/16.66);

    // Balls
    for(const b of world.balls){
      if(b.sleep) continue;
      // Integrate (y is height above floor => gravity pulls down)
      b.vy -= g;
      b.vx *= air; b.vy *= air; b.vz *= air;
      b.x += b.vx; b.y += b.vy; b.z += b.vz;

      // Arena walls
      if(b.x < -world.arenaHalfWidthX + b.r){ b.x = -world.arenaHalfWidthX + b.r; b.vx *= -0.5; }
      if(b.x >  world.arenaHalfWidthX - b.r){ b.x =  world.arenaHalfWidthX - b.r; b.vx *= -0.5; }
      if(b.z < b.r){ b.z = b.r; b.vz *= -0.5; }
      if(b.z > world.arenaDepthZ - b.r){ b.z = world.arenaDepthZ - b.r; b.vz *= -0.5; }

      // Floor collision (floor at y=0)
      if(b.y - b.r < floorY){
        b.y = floorY + b.r;
        b.vy *= -bounce;
        b.vx = (b.vx)*0.985 + rand(-0.08,0.08); // add tiny random tangential energy
        b.vz = (b.vz)*0.985 + rand(-0.08,0.08);
        if(Math.abs(b.vy) < 0.25 && Math.abs(b.vx) < 0.05 && Math.abs(b.vz) < 0.05){
          b.vy = 0; b.vx *= 0.97; b.vz *= 0.97; b.sleep = true;
        }
      }

      // Gentle sleeping friction
      if(b.sleep){
        b.vx *= 0.985; b.vz *= 0.985; if(Math.abs(b.vx) < 0.02) b.vx = 0; if(Math.abs(b.vz) < 0.02) b.vz = 0;
      }
    }

    // Build XZ spatial grid (store indices to avoid duplicates)
    gridXZ.clear();
    const balls = world.balls;
    for(let i=0;i<balls.length;i++){
      const bi = balls[i];
      const k = keyXZ(bi.x, bi.z);
      let arr = gridXZ.get(k); if(!arr){ arr=[]; gridXZ.set(k, arr); }
      arr.push(i);
    }

    // Sphere-sphere collisions (3D) using neighboring cells
    const offsets = [-1,0,1];
    const restitution = 0.5;
    for(let i=0;i<balls.length;i++){
      const a = balls[i];
      const gx = (a.x/cellXZ)|0, gz = (a.z/cellXZ)|0;
      for(let ox of offsets){
        for(let oz of offsets){
          const arr = gridXZ.get((gx+ox)+","+(gz+oz));
          if(!arr) continue;
          for(let idx=0; idx<arr.length; idx++){
            const j = arr[idx];
            if(j <= i) continue;
            const b = balls[j];
            // quick y-plane rejection
            const maxDist = a.r + b.r;
            if(Math.abs(a.y - b.y) > maxDist) continue;
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dz = b.z - a.z;
            const d2 = dx*dx + dy*dy + dz*dz;
            if(d2 > maxDist*maxDist || d2 === 0) continue;
            const d = Math.sqrt(d2) || 0.0001;
            const nx = dx/d, ny = dy/d, nz = dz/d;
            const overlap = (maxDist - d);
            // positional correction proportional to inverse mass
            const im1 = 1/a.m, im2 = 1/b.m;
            const totalInv = im1 + im2;
            const corr = overlap * 0.5;
            a.x -= nx * corr * (im1/totalInv);
            a.y -= ny * corr * (im1/totalInv);
            a.z -= nz * corr * (im1/totalInv);
            b.x += nx * corr * (im2/totalInv);
            b.y += ny * corr * (im2/totalInv);
            b.z += nz * corr * (im2/totalInv);
            // velocity resolution
            const rvx = b.vx - a.vx;
            const rvy = b.vy - a.vy;
            const rvz = b.vz - a.vz;
            const relVelN = rvx*nx + rvy*ny + rvz*nz;
            if(relVelN > 0) continue;
            const jImpulse = -(1+restitution) * relVelN / (im1 + im2);
            const impX = jImpulse * nx, impY = jImpulse * ny, impZ = jImpulse * nz;
            a.vx -= impX * im1; a.vy -= impY * im1; a.vz -= impZ * im1;
            b.vx += impX * im2; b.vy += impY * im2; b.vz += impZ * im2;
          }
        }
      }
    }
  }

  // ===== Render =====
  function draw(){
    // Background
    ctx.clearRect(0,0,W,H);

    // Subtle vignette
    const grd = ctx.createRadialGradient(W*0.5, H*0.15, 80, W*0.5, H*0.2, Math.max(W,H));
    grd.addColorStop(0,'rgba(255,255,255,0.04)');
    grd.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    // Floor grid in perspective
    drawFloorGrid();

    // Balls (sorted back-to-front)
    const sorted = world.balls.slice().sort((a,b)=> (b.z - a.z));
    for(const b of sorted){
      const proj = project3D(b);

      // Shadow ellipse on floor position beneath ball
      const floorProj = project3D({x:b.x, y:0, z:b.z});
      const heightFactor = clamp(1 - (b.y - b.r)/380, 0, 1);
      const shadowScale = Math.max(0, proj.scale * heightFactor);
      const shadowAlpha = 0.22 * heightFactor;
      const shadowW = Math.max(0.0001, b.r * 2.6 * shadowScale);
      const shadowH = Math.max(0.0001, shadowW * 0.45);
      ctx.fillStyle = `rgba(0,0,0,${clamp(shadowAlpha,0,0.25)})`;
      ctx.beginPath(); ctx.ellipse(floorProj.x, floorProj.y, shadowW, shadowH, 0, 0, Math.PI*2); ctx.fill();

      // Glow
      const glow = ctx.createRadialGradient(proj.x, proj.y, Math.max(0.001, 2*proj.scale), proj.x, proj.y, Math.max(0.002, b.r*2.6*proj.scale));
      glow.addColorStop(0, b.color + '');
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(proj.x, proj.y, b.r*2.2*proj.scale, 0, Math.PI*2); ctx.fill();

      // Core sphere with simple lighting
      const coreR = b.r * proj.scale;
      // fake rim lighting by darkening edge
      const rim = ctx.createRadialGradient(proj.x, proj.y, Math.max(0.001, coreR*0.65), proj.x, proj.y, Math.max(0.002, coreR));
      rim.addColorStop(0, 'rgba(0,0,0,0)');
      rim.addColorStop(1, 'rgba(0,0,0,0.25)');
      const lightX = -0.6, lightY = -0.8; // pseudo light dir
      const grad = ctx.createRadialGradient(
        proj.x + coreR*lightX*0.45,
        proj.y + coreR*lightY*0.45,
        Math.max(0.001, coreR*0.18),
        proj.x,
        proj.y,
        Math.max(0.002, coreR)
      );
      grad.addColorStop(0, 'rgba(255,255,255,0.85)');
      grad.addColorStop(0.12, 'rgba(255,255,255,0.6)');
      grad.addColorStop(0.2, b.color);
      grad.addColorStop(1, b.color);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, coreR, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = rim; ctx.beginPath(); ctx.arc(proj.x, proj.y, coreR, 0, Math.PI*2); ctx.fill();

      // Label (symbol)
      if(b.r > 14 && b.label){
        ctx.font = '600 10px ui-sans-serif, system-ui, -apple-system';
        ctx.fillStyle = 'rgba(0,0,0,.45)';
        ctx.textAlign = 'center';
        ctx.fillText(b.label.toUpperCase(), proj.x+1, proj.y+3);
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.fillText(b.label.toUpperCase(), proj.x, proj.y+2);
      }
    }
  }

  function drawFloorGrid(){
    const gridColor = 'rgba(255,255,255,0.08)';
    ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
    const half = world.arenaHalfWidthX;
    // depth lines (constant x)
    for(let x=-half; x<=half; x+= 80){
      const p0 = project3D({x, y:0, z: 0});
      const p1 = project3D({x, y:0, z: world.arenaDepthZ});
      ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
    }
    // horizontal lines (constant z)
    for(let z=0; z<=world.arenaDepthZ; z+= 120){
      const p0 = project3D({x:-half, y:0, z});
      const p1 = project3D({x: half, y:0, z});
      ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
    }
    // back wall faint line
    const bw0 = project3D({x:-half, y:0, z:world.arenaDepthZ});
    const bw1 = project3D({x: half, y:0, z:world.arenaDepthZ});
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.moveTo(bw0.x, bw0.y); ctx.lineTo(bw1.x, bw1.y); ctx.stroke();

    // vignetting at edges
    const grad = ctx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0, 'rgba(0,0,0,0.06)');
    grad.addColorStop(1, 'rgba(0,0,0,0.18)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);
  }

  // ===== Loop =====
  let last = performance.now();
  function loop(t){
    const dt = t - last; last = t;
    if(world.running){
      step(dt);
      draw();

      // Auto stream
      if(auto.checked){
        world.lastSpawn += dt;
        const per = 1000/Number(rate.value || 1);
        const ro = world.randomOptions;
        while(world.lastSpawn >= per){
          world.lastSpawn -= per;
          const isBuy = Math.random() < ro.buyProbability;
          const lots = rand(ro.lotsRange[0], ro.lotsRange[1]);
          const big = Math.random() < ro.bigProfitChance;
          const profit = big ? rand(ro.profitRangeBig[0], ro.profitRangeBig[1])
                             : rand(ro.profitRangeSmall[0], ro.profitRangeSmall[1]);
          const symbol = ro.symbolPool[(Math.random()*ro.symbolPool.length)|0];
          spawnBall({
            side: isBuy ? 'buy':'sell',
            lots,
            profitUSD: profit,
            symbol
          });
        }
      }
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== Controls =====
  const gravity = document.getElementById('gravity');
  const gravityVal = document.getElementById('gravityVal');
  const rate = document.getElementById('rate');
  const rateVal = document.getElementById('rateVal');
  const maxBalls = document.getElementById('maxBalls');
  const maxVal = document.getElementById('maxVal');
  const toggle = document.getElementById('toggle');
  const clearBtn = document.getElementById('clear');
  const auto = document.getElementById('auto');
  const fullscreenBtn = document.getElementById('fullscreen');

  gravity.addEventListener('input', () => {
    world.gravity = Number(gravity.value);
    gravityVal.textContent = world.gravity.toFixed(2);
  });
  rate.addEventListener('input', () => { rateVal.textContent = rate.value; world.spawnInterval= 1000/Number(rate.value||1); });
  maxBalls.addEventListener('input', () => {
    world.maxBalls = Number(maxBalls.value);
    maxVal.textContent = maxBalls.value;
    if(world.balls.length > world.maxBalls){
      world.balls.splice(0, world.balls.length - world.maxBalls);
    }
  });

  toggle.addEventListener('click', () => { world.running = !world.running; toggle.textContent = world.running ? 'Pause' : 'Resume'; });
  clearBtn.addEventListener('click', () => { world.balls.length = 0; });

  // Fullscreen toggle and HUD hide
  async function enterFullscreen(){
    const el = document.documentElement;
    if(el.requestFullscreen){ await el.requestFullscreen(); }
    else if(el.webkitRequestFullscreen){ el.webkitRequestFullscreen(); }
  }
  async function exitFullscreen(){
    if(document.exitFullscreen){ await document.exitFullscreen(); }
    else if(document.webkitExitFullscreen){ document.webkitExitFullscreen(); }
  }
  function setHudHidden(hidden){
    const hud = document.querySelector('.hud');
    if(!hud) return;
    hud.classList.toggle('hidden', hidden);
  }
  let hudHidden = false;
  fullscreenBtn.addEventListener('click', async ()=>{
    try{
      if(!document.fullscreenElement && !(document.webkitFullscreenElement)){
        await enterFullscreen();
        hudHidden = true; setHudHidden(true);
        fullscreenBtn.textContent = 'Exit Fullscreen';
      }else{
        await exitFullscreen();
        hudHidden = false; setHudHidden(false);
        fullscreenBtn.textContent = 'Fullscreen';
      }
    }catch(err){ /* ignore */ }
  });
  document.addEventListener('fullscreenchange', ()=>{
    if(!document.fullscreenElement && !(document.webkitFullscreenElement)){
      hudHidden = false; setHudHidden(false);
      fullscreenBtn.textContent = 'Fullscreen';
    }
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='k'){
      for(let i=0;i<20;i++) spawnBall({ side: Math.random()<0.5?'buy':'sell', lots: Math.random()*1.5, profitUSD: rand(10,500)});
    }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='f'){
      fullscreenBtn.click();
    }
  });

  // Copy API helper on click of card
  document.getElementById('help').addEventListener('click', async ()=>{
    try{
      const codeEl = document.querySelector('#help code');
      await navigator.clipboard.writeText(codeEl ? codeEl.textContent : '');
      const t = document.getElementById('toast'); t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1200);
    }catch(err){/* ignore */}
  });

  // Initial warmup
  for(let i=0;i<35;i++) spawnBall({ side: Math.random()<0.5?'buy':'sell', lots: rand(world.randomOptions.lotsRange[0], world.randomOptions.lotsRange[1]), profitUSD: rand(15,800), symbol: world.randomOptions.symbolPool[(Math.random()*world.randomOptions.symbolPool.length)|0]});
})();
</script>
</body>
</html>