<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trade Rain — Plinko-Style (Standalone)</title>
  <style>
    :root{
      --bg:#0b1220; /* deep navy */
      --panel:#111a2b;
      --accent:#48d597;
      --accent-2:#ef4444;
      --ink:#e6f0ff;
      --muted:#7b8aa1;
      --peg:#1f2d47;
      --grid:#0f1a30;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% -10%, #18243d 0%, var(--bg) 60%);}    
    body{font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; color:var(--ink);}

    /* Layout */
    .wrap{position:fixed; inset:0; display:grid; grid-template-columns: 1fr;}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}

    /* HUD */
    .hud{position:fixed; top:16px; right:16px; display:flex; gap:12px; align-items:flex-start; z-index:10}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03)); border:1px solid rgba(255,255,255,0.08); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border-radius:16px; padding:12px 14px; box-shadow: 0 10px 30px rgba(0,0,0,.25);} 
    .card h3{margin:0 0 8px 0; font-size:13px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted)}
    .row{display:flex; gap:8px; align-items:center; margin:8px 0}
    label{font-size:12px; color:var(--muted)}
    input[type="range"]{width:140px}
    .pill{display:inline-flex; align-items:center; gap:8px; background:#0f1a30; border:1px solid #1c2a45; padding:6px 10px; border-radius:999px; font-size:12px}
    .btn{cursor:pointer; user-select:none; border:none; border-radius:12px; padding:8px 12px; font-weight:600; background:#16223a; color:#dbe7ff; border:1px solid #203055; transition:transform .06s ease, background .2s}
    .btn:hover{background:#1a2a4a}
    .btn:active{transform:translateY(1px)}
    .dot{width:10px; height:10px; border-radius:50%}
    .dot.green{background:var(--accent)}
    .dot.red{background:var(--accent-2)}

    /* Footer */
    .footer{position:fixed; left:16px; bottom:16px; display:flex; gap:10px; align-items:center; z-index:10}
    .tag{font-size:12px; color:var(--muted)}

    /* Tooltip */
    .toast{position:fixed; left:50%; transform:translateX(-50%); top:16px; background:#0e1730; border:1px solid #203055; color:#dbe7ff; padding:8px 12px; border-radius:10px; font-size:12px; opacity:0; pointer-events:none; transition: opacity .25s ease}
    .toast.show{opacity:1}

    /* Bottom bins */
    .bins{position:fixed; left:0; right:0; bottom:0; height:120px; pointer-events:none}
    .bin{position:absolute; bottom:0; width:2px; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,0));}

    /* Nice subtle grid */
    .fg-grid{position:fixed; inset:0; pointer-events:none; background-image: linear-gradient(var(--grid) 1px, transparent 1px), linear-gradient(90deg, var(--grid) 1px, transparent 1px); background-size: 60px 60px; mask: linear-gradient(to bottom, rgba(0,0,0,.18), rgba(0,0,0,.6));}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="stage"></canvas>
    <div class="fg-grid"></div>

    <div class="hud">
      <div class="card" id="controls">
        <h3>Live Controls</h3>
        <div class="row">
          <button class="btn" id="toggle">Pause</button>
          <button class="btn" id="clear">Clear</button>
          <span class="pill"><span class="dot green"></span>Buy</span>
          <span class="pill"><span class="dot red"></span>Sell</span>
        </div>
        <div class="row">
          <label>Gravity</label>
          <input id="gravity" type="range" min="0" max="3" step="0.05" value="1.1" />
          <span id="gravityVal" class="tag">1.10</span>
        </div>
        <div class="row">
          <label>Spawn/sec</label>
          <input id="rate" type="range" min="0" max="15" step="1" value="6" />
          <span id="rateVal" class="tag">6</span>
        </div>
        <div class="row">
          <label>Max Balls</label>
          <input id="maxBalls" type="range" min="50" max="800" step="10" value="350" />
          <span id="maxVal" class="tag">350</span>
        </div>
        <div class="row">
          <label>Auto-Stream</label>
          <input id="auto" type="checkbox" checked />
        </div>
      </div>

      <div class="card" id="help">
        <h3>How to feed trades</h3>
        <div class="tag">From the console or another script, call:</div>
        <pre style="margin:6px 0 0; padding:8px 10px; background:#0c1530; border:1px solid #203055; border-radius:10px; overflow:auto; max-width:420px"><code style="font-size:12px; color:#bcd9ff; display:block">window.pushTrade({ side: "buy", lots: 0.3, profitUSD: 42, symbol: "XAUUSD" })
window.pushTrade({ side: "sell", profitUSD: -350, symbol: "BTCUSD" })
window.setTradeAdapter((p) => ({ side: p.s > 0 ? "buy" : "sell", profitUSD: p.s, symbol: p.sym, lots: p.l || 0.2 }))
window.setRandomStreamOptions({ buyProbability: 0.6, symbolPool: ["XAUUSD","EURUSD","US30"], bigProfitChance: 0.2 })</code></pre>
      </div>
    </div>

    <div class="footer">
      <div class="tag">Trade Rain · Canvas physics demo · ⌘/Ctrl+K to spawn 20</div>
    </div>

    <div id="toast" class="toast">Copied API usage to clipboard</div>

    <div class="bins" id="bins"></div>
  </div>

<script>
(function(){
  // ===== Utilities =====
  const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const rand = (a,b) => Math.random()*(b-a)+a;

  // ===== Canvas & Scene =====
  const c = document.getElementById('stage');
  const ctx = c.getContext('2d');
  let W=0,H=0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));

  const world = {
    gravity: 1.1, // px/frame^2 (scaled by DPR)
    running: true,
    maxBalls: 350,
    balls: [],
    lastSpawn: 0,
    spawnInterval: 1000/6, // ms per ball in auto mode
    adapter: null,
    randomOptions: {
      buyProbability: 0.5,
      symbolPool: ["XAUUSD","EURUSD","BTCUSD"],
      lotsRange: [0.05, 1.5],
      profitRangeSmall: [5, 250],
      profitRangeBig: [250, 2000],
      bigProfitChance: 0.3,
    },
    // 3D arena
    arenaHalfWidthX: 600,
    arenaDepthZ: 1400,
    arenaFloorY: 0,
    perspective: 1200
  };

  // ===== 3D Projection helpers =====
  const FLOOR_SCREEN_Y = () => H - 90; // where the floor baseline renders on screen
  const Z_SKEW = 0.08; // lifts far objects to fake floor tilt
  function project3D(pos){
    const persp = world.perspective;
    const scale = persp / (persp + pos.z);
    const sx = (W*0.5) + pos.x * scale;
    const sy = FLOOR_SCREEN_Y() - pos.y * scale - pos.z * Z_SKEW;
    return { x: sx, y: sy, scale };
  }

  function resize(){
    W = c.clientWidth = window.innerWidth;
    H = c.clientHeight = window.innerHeight;
    c.width = Math.floor(W*DPR);
    c.height = Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    // nothing else for 3D scene
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // (Plinko grid and spatial hash removed)

  // ===== Balls =====
  class Ball{
    constructor({x,y,z,r,color,label}){
      this.x = x; this.y = y; this.z = z; this.r = r; this.color = color; this.label = label||'';
      this.vx = rand(-0.5,0.5); this.vy = 0; this.vz = rand(-0.2,0.2);
      this.sleep = false; // when settled at the bottom
    }
  }

  function mapRadiusFromProfitUSD(usd){
    const s = Math.log10(Math.abs(usd) + 10); // log scale
    const sMin = Math.log10(10); // 1
    const sMax = Math.log10(2000 + 10); // ~3.303
    const t = clamp((s - sMin) / (sMax - sMin), 0, 1);
    return lerp(6, 26, t);
  }
  function mapRadiusFromLots(lots){
    const l = clamp(lots, 0.05, 3.0);
    const t = (l - 0.05) / (3.0 - 0.05);
    return lerp(6, 26, clamp(t, 0, 1));
  }

  function spawnBall(trade){
    const side = (trade?.side||'buy').toLowerCase();
    const lots = Number(trade?.lots ?? 0.2);
    const usd = Number(trade?.profitUSD);
    // Radius mapping: 6px to 26px based on |usd| or lots
    const r = Math.round(
      isFinite(usd) && !Number.isNaN(usd) ? mapRadiusFromProfitUSD(usd) : mapRadiusFromLots(lots)
    );
    const color = side==='sell' ? '#ef4444' : '#48d597';

    const x = rand(-world.arenaHalfWidthX*0.85, world.arenaHalfWidthX*0.85);
    const z = rand(40, world.arenaDepthZ*0.25);
    const y = rand(220, 360);
    const b = new Ball({x,y,z,r,color,label: trade?.symbol||''});
    world.balls.push(b);
    if(world.balls.length > world.maxBalls){
      world.balls.splice(0, world.balls.length - world.maxBalls);
    }
  }

  // Public API to feed trades
  window.pushTrade = function(trade){
    try{
      if(typeof world.adapter === 'function'){
        const adapted = world.adapter(trade);
        if(adapted && typeof adapted === 'object') trade = adapted;
      }
    }catch(e){ /* ignore adapter errors */ }
    spawnBall(trade);
  }

  window.setTradeAdapter = function(adapter){
    world.adapter = (typeof adapter === 'function') ? adapter : null;
  }

  window.setRandomStreamOptions = function(opts={}){
    const ro = world.randomOptions;
    if('buyProbability' in opts && typeof opts.buyProbability === 'number') ro.buyProbability = clamp(opts.buyProbability, 0, 1);
    if(Array.isArray(opts.symbolPool) && opts.symbolPool.length) ro.symbolPool = opts.symbolPool.slice(0, 24);
    if(Array.isArray(opts.lotsRange) && opts.lotsRange.length===2) ro.lotsRange = [Math.max(0.01, opts.lotsRange[0]), Math.max(0.02, opts.lotsRange[1])];
    if(Array.isArray(opts.profitRangeSmall) && opts.profitRangeSmall.length===2) ro.profitRangeSmall = opts.profitRangeSmall;
    if(Array.isArray(opts.profitRangeBig) && opts.profitRangeBig.length===2) ro.profitRangeBig = opts.profitRangeBig;
    if('bigProfitChance' in opts && typeof opts.bigProfitChance === 'number') ro.bigProfitChance = clamp(opts.bigProfitChance, 0, 1);
  }

  // ===== Physics =====
  const bounce = 0.55; // restitution on floor
  const air = 0.998;   // air drag
  const floorY = 0;    // world floor plane y

  function step(dt){
    const g = world.gravity * (dt/16.66);

    // Balls
    for(const b of world.balls){
      if(b.sleep) continue;
      // Integrate (y is height above floor => gravity pulls down)
      b.vy -= g;
      b.vx *= air; b.vy *= air; b.vz *= air;
      b.x += b.vx; b.y += b.vy; b.z += b.vz;

      // Arena walls
      if(b.x < -world.arenaHalfWidthX + b.r){ b.x = -world.arenaHalfWidthX + b.r; b.vx *= -0.5; }
      if(b.x >  world.arenaHalfWidthX - b.r){ b.x =  world.arenaHalfWidthX - b.r; b.vx *= -0.5; }
      if(b.z < b.r){ b.z = b.r; b.vz *= -0.5; }
      if(b.z > world.arenaDepthZ - b.r){ b.z = world.arenaDepthZ - b.r; b.vz *= -0.5; }

      // Floor collision (floor at y=0)
      if(b.y - b.r < floorY){
        b.y = floorY + b.r;
        b.vy *= -bounce;
        b.vx *= 0.985; b.vz *= 0.985;
        if(Math.abs(b.vy) < 0.25 && Math.abs(b.vx) < 0.05 && Math.abs(b.vz) < 0.05){
          b.vy = 0; b.vx *= 0.97; b.vz *= 0.97; b.sleep = true;
        }
      }

      // Gentle sleeping friction
      if(b.sleep){
        b.vx *= 0.985; b.vz *= 0.985; if(Math.abs(b.vx) < 0.02) b.vx = 0; if(Math.abs(b.vz) < 0.02) b.vz = 0;
      }
    }
  }

  // ===== Render =====
  function draw(){
    // Background
    ctx.clearRect(0,0,W,H);

    // Subtle vignette
    const grd = ctx.createRadialGradient(W*0.5, H*0.15, 80, W*0.5, H*0.2, Math.max(W,H));
    grd.addColorStop(0,'rgba(255,255,255,0.04)');
    grd.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    // Floor grid in perspective
    drawFloorGrid();

    // Balls (sorted back-to-front)
    const sorted = world.balls.slice().sort((a,b)=> b.z - a.z);
    for(const b of sorted){
      const proj = project3D(b);

      // Shadow ellipse on floor position beneath ball
      const floorProj = project3D({x:b.x, y:0, z:b.z});
      const heightFactor = clamp(1 - (b.y - b.r)/300, 0, 1);
      const shadowScale = Math.max(0, proj.scale * heightFactor);
      const shadowAlpha = 0.18 * heightFactor;
      const shadowW = Math.max(0.0001, b.r * 2.2 * shadowScale);
      const shadowH = Math.max(0.0001, shadowW * 0.45);
      ctx.fillStyle = `rgba(0,0,0,${clamp(shadowAlpha,0,0.25)})`;
      ctx.beginPath(); ctx.ellipse(floorProj.x, floorProj.y, shadowW, shadowH, 0, 0, Math.PI*2); ctx.fill();

      // Glow
      const glow = ctx.createRadialGradient(proj.x, proj.y, Math.max(0.001, 2*proj.scale), proj.x, proj.y, Math.max(0.002, b.r*2.2*proj.scale));
      glow.addColorStop(0, b.color + '');
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(proj.x, proj.y, b.r*2.2*proj.scale, 0, Math.PI*2); ctx.fill();

      // Core sphere with simple lighting
      const coreR = b.r * proj.scale;
      const lightX = -0.6, lightY = -0.8; // pseudo light dir
      const grad = ctx.createRadialGradient(
        proj.x + coreR*lightX*0.5,
        proj.y + coreR*lightY*0.5,
        coreR*0.2,
        proj.x,
        proj.y,
        coreR
      );
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.08, '#ffffff');
      grad.addColorStop(0.12, b.color);
      grad.addColorStop(1, b.color);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, coreR, 0, Math.PI*2);
      ctx.fill();

      // Label (symbol)
      if(b.r > 14 && b.label){
        ctx.font = '600 10px ui-sans-serif, system-ui, -apple-system';
        ctx.fillStyle = 'rgba(0,0,0,.45)';
        ctx.textAlign = 'center';
        ctx.fillText(b.label.toUpperCase(), proj.x+1, proj.y+3);
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.fillText(b.label.toUpperCase(), proj.x, proj.y+2);
      }
    }
  }

  function drawFloorGrid(){
    const gridColor = 'rgba(255,255,255,0.08)';
    ctx.strokeStyle = gridColor; ctx.lineWidth = 1;
    const half = world.arenaHalfWidthX;
    // depth lines (constant x)
    for(let x=-half; x<=half; x+= 80){
      const p0 = project3D({x, y:0, z: 0});
      const p1 = project3D({x, y:0, z: world.arenaDepthZ});
      ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
    }
    // horizontal lines (constant z)
    for(let z=0; z<=world.arenaDepthZ; z+= 120){
      const p0 = project3D({x:-half, y:0, z});
      const p1 = project3D({x: half, y:0, z});
      ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
    }
    // back wall faint line
    const bw0 = project3D({x:-half, y:0, z:world.arenaDepthZ});
    const bw1 = project3D({x: half, y:0, z:world.arenaDepthZ});
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.moveTo(bw0.x, bw0.y); ctx.lineTo(bw1.x, bw1.y); ctx.stroke();
  }

  // ===== Loop =====
  let last = performance.now();
  function loop(t){
    const dt = t - last; last = t;
    if(world.running){
      step(dt);
      draw();

      // Auto stream
      if(auto.checked){
        world.lastSpawn += dt;
        const per = 1000/Number(rate.value || 1);
        const ro = world.randomOptions;
        while(world.lastSpawn >= per){
          world.lastSpawn -= per;
          const isBuy = Math.random() < ro.buyProbability;
          const lots = rand(ro.lotsRange[0], ro.lotsRange[1]);
          const big = Math.random() < ro.bigProfitChance;
          const profit = big ? rand(ro.profitRangeBig[0], ro.profitRangeBig[1])
                             : rand(ro.profitRangeSmall[0], ro.profitRangeSmall[1]);
          const symbol = ro.symbolPool[(Math.random()*ro.symbolPool.length)|0];
          spawnBall({
            side: isBuy ? 'buy':'sell',
            lots,
            profitUSD: profit,
            symbol
          });
        }
      }
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== Controls =====
  const gravity = document.getElementById('gravity');
  const gravityVal = document.getElementById('gravityVal');
  const rate = document.getElementById('rate');
  const rateVal = document.getElementById('rateVal');
  const maxBalls = document.getElementById('maxBalls');
  const maxVal = document.getElementById('maxVal');
  const toggle = document.getElementById('toggle');
  const clearBtn = document.getElementById('clear');
  const auto = document.getElementById('auto');

  gravity.addEventListener('input', () => {
    world.gravity = Number(gravity.value);
    gravityVal.textContent = world.gravity.toFixed(2);
  });
  rate.addEventListener('input', () => { rateVal.textContent = rate.value; world.spawnInterval= 1000/Number(rate.value||1); });
  maxBalls.addEventListener('input', () => {
    world.maxBalls = Number(maxBalls.value);
    maxVal.textContent = maxBalls.value;
    if(world.balls.length > world.maxBalls){
      world.balls.splice(0, world.balls.length - world.maxBalls);
    }
  });

  toggle.addEventListener('click', () => { world.running = !world.running; toggle.textContent = world.running ? 'Pause' : 'Resume'; });
  clearBtn.addEventListener('click', () => { world.balls.length = 0; });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='k'){
      for(let i=0;i<20;i++) spawnBall({ side: Math.random()<0.5?'buy':'sell', lots: Math.random()*1.5, profitUSD: rand(10,500)});
    }
  });

  // Copy API helper on click of card
  document.getElementById('help').addEventListener('click', async ()=>{
    try{
      const codeEl = document.querySelector('#help code');
      await navigator.clipboard.writeText(codeEl ? codeEl.textContent : '');
      const t = document.getElementById('toast'); t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1200);
    }catch(err){/* ignore */}
  });

  // Initial warmup
  for(let i=0;i<35;i++) spawnBall({ side: Math.random()<0.5?'buy':'sell', lots: rand(world.randomOptions.lotsRange[0], world.randomOptions.lotsRange[1]), profitUSD: rand(15,800), symbol: world.randomOptions.symbolPool[(Math.random()*world.randomOptions.symbolPool.length)|0]});
})();
</script>
</body>
</html>